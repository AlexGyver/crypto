Всем привет! После долгого перерыва хотелось показать вам что-то круто и железное, но буквально пару дней назад у меня появилась интересная идея для видоса на тему алгоритмов и всего такого. Поэтому сегодня вас ждёт небольшое погружение в цифровой мир, щепотка школьной информатики и рассказ о моих попытках закодировать текст внутри картинки. Будет научпоп, наливайте чай.
На днях мой соведущий со второго канала предложил мне снять видос о методах шифрования, на что я ответил что абсолютно ничего в этом не смыслю, потому что никогда с этим не сталкивался, да и звучит как то скучно и все методы давно описаны на википедии. Я подумал, а как можно так извратиться, чтобы сделать что то необычное и интересное? У меня на канале уже был ролик, где я успешно передавал изображение по лучу лазера, и он вроде как вам понравился. И тут я понял, что было бы жутко интересно зашифровать не текст в тексте, а текст в картинке, потому что картинка на самом деле это тот же самый текст. Давайте попробуем.
Для работы я буду использовать бесплатную среду разработки processing, которая создана для того, что программировать могли всякие дизайнеры и домохозяйки. Её даже устанавливать не нужно, скачал запустил и кодишь себе на какой то смеси Java с картоном. Кстати на западе процессинг очень активно используют в школах и универах, не знаю почему мы до сих пор ковыряем паскаль и не идём в ногу со временем. 
А мы с вами, прежде чем начать кодить, вспомним некоторые базовые вещи, чтобы понять как это всё будет работать, а именно – как компьютер хранит и обрабатывает изображение и текст. Изображения бывают двух типов – векторные и растровые. Файл векторного изображения содержит в себе грубо говоря набор уравнений, которые описывают каждую линию, область и фигуру, из которой состоит изображение. Такие изображения нам не подходят. Растровое изображение представляет собой набор точек, пикселей, каждый имеет свой цвет и положение на картинке. Вот это уже интереснее. На данный момент существует довольно таки много различных форматов изображения, но в основе всего лежит формат bmp, файл которого содержит в себе просто список пикселей, то есть фактически цвет каждого пикселя. Именно так мы работали с картинками когда передавали их по лазеру. После появления бмп появились алгоритмы сжатия изображения, например тот же жипег, он содержит намного меньше информации за счёт алгоритмов сжатия, из за которых также теряется часть информации. Так что сегодня мы будем работать именно с бмп, так как он не испортит цветовые данные и сокрытый среди них текст. 
Немного цветовой теории. Цвет в представлении компьютера задаётся тремя базовыми цветами, красным зелёным и синим. Смешивая эти три цвета в разных соотношениях можно получить другие цвета и их оттенки. Очень много где используется стандарт глубины цвета 24 бита, я думаю вы не раз видели такую цифру. А ещё чаще вы могли видеть цифру 16,7 миллионов цветов и оттенков, применительно к дисплеям. Эти две цифры связаны через степень, потому что 24 бита это и есть 16,7 миллионов значений. Также 24 бита это 3 по 8, по 8 бит на каждый из трёх базовых цветов. 8 бит это значение от 0 до 255, то есть каждый цвет имеет всего 256 градаций яркости, но вместе они дают 16,7 млн комбинаций и оттенков. Вот такая математика. Стандартный бмп файл также имеет глубину 24 бита и очень несложно представить, что у него там под капотом.
А что у нас с текстовыми файлами? Текст – это такой же набор байтов, закодированный особым образом. Каждой букве и символу соответствует число, это соответствие задаёт таблица ASCII. Вот её стандартный вид, русских букв тут нет и они кодируются другими числами в зависимости от кодировки файла. Как несложно заметить, весь алфавит и символы умещаются в один байт. Чтож, осталось нам сделать РРАР, совместить одни цифры с другими, давайте подумаем как это может быть сделано. Я не буду углубляться в код на процессинге, он довольно простой и желающие могут сами его поковырять так как я выложу все исходники на гитхаб, а вся документация есть на официальном сайте. 
Начать предлагаю с самого примитивного: берём исходное изображение и к значению каждого пикселя по порядку просто прибавляем код символа в тексте по порядку. Диапазон цвета у нас от 0 до почти 17 миллионов, а буквы – не более 120. Фактически цвет и не должен даже измениться от такой незначительной прибавки. В итоге у нас получится два изображения: оригинальное и с зашитым текстом. Используя оригинальное изображение как ключ, можно попиксельно вычесть его из зашифрованного и останется только текст. То есть если у нас и у того, кому мы хотим передать шифровку есть оригинал изображения, мы с ним можем обмениваться скрытыми сообщениями.
Я сделал не побоюсь этого слова программу, в которой есть кнопощки, и можно выбрать файл исходного изображения в любом формате, выбрать текст в формате текстового файла, нажать на энкрипт и получить зашифрованную картинку в формате бмп. В обратную сторону: загружаем исходную картинку, загружаем зашифрованную, нажимаем декрипт и получаем текст. Работает?  Работает. Текст также выводится в тхт файл. А теперь в вопросу о том, как выглядит наше изображение, и выглядит оно заметно не очень. А точнее, оно посинело там, где зашифрован текст. 
Сейчас давайте попробуем решить проблему в лоб. Мы знаем длину текста и размер изображения, соответственно можем равномерно распределить все буквы по пикселям. При расшифровке мы не будем знать длину текста, поэтому можно в самый первый пиксель зашифровать размер шага, и со второго пикселя с этим шагом шифровать буквы. При расшифровке повторить процесс в обратном порядке, и всё. Работает? Работает. Картинка выглядит вот так. Стало ли лучше? Ну хз, теперь появились синие полосы. 
Продолжим решать проблему в лоб и сделаем следующее: размажем значение буквы по всему промежутку между двумя соседними буквами. Если текст сильно меньше картинки, то буква размажется по единичкам и не внесёт никакого визуального изменения в исходное изображение. Проверяем. Работает. Картинка стала выглядеть вот так и кажется задача решена, но есть два больших но. Если на изображении будет область с полностью белым цветом, мы ничего не сможем туда записать, потому что это уже максимум. А если там почти белый, то часть информации потеряется и мы опять же получим битые символы. А если на изображении будет синий цвет, то даже небольшое прибавленное значение может полностью его исказить. Почему? И тут в дело вступает школьная информатика, а именно бинарная математика.
Дело в том, что результирующий цвет не является перемножением или сложением основных цветов, там процесс гораздо более сложный и интересный. У каждого базового цвета в основном цвете есть своё определённое место, так как это именно 24 битный цвет. Каждый байт содержит 8 бит, итоговый цвет строится вот так. То есть красный цвет на самом деле имеет значение примерно от 65536 до 16711680, зелёный от 256 до 65280, и синий от 0 до 255. Прибавляя какое то значение к общему цвету мы фактически увеличиваем только синий канал, и если байт синего канала переполняется, он возвращается обратно в 0 и увеличивает также соседний зелёный канал. Таким образом если цвет пикселя содержал синий, то после прибавления кода буквы он рискует этот синий просто потерять. Причём если это был например серый, то без синего он станет жёлтым, так как в нём останется только красный и зелёный. То есть если мы хотим зашифровать картинку так, чтобы визуально не было вообще никаких искажений, нам придётся полностью менять стратегию.
На самом деле исходная картинка для этого дела вообще не нужна, потому что текст можно зашить прямо в изображение практически не внося изменений в цвет. Если менять младший бит одного цвета, или даже два, итоговый цвет практически не изменится, то есть мы можем прямо хранить там букву и не нужно будет искать никакой разности с исходной картинкой. И тут нам нужно будет сделать следующее: у нас есть три байта цвета и один байт буквы. Мы разбиваем байт буквы на 3 кусочка, например 3 2 3, и записываем как младшие биты основных цветов. Данная операция делается при помощи сдвигов и выглядит примерно вот так. При расшифровке мы собираем наш байт обратно вот таким образом. И такой способ не вносит никаких видимых изменений в цвет несмотря на то, что мы прямо таки записали буквы в пиксели. И это реально круто. Но как нам теперь защитить изображение от расшифровки? Я решил действовать максимально хитро и использовать случайные числа. 
Как известно, компьютер не может генерировать именно случайные числа, потому что он выполняет только строгие математические операции. В процессинг у нас есть функция рандом, которая делает псевдослучайные числа. Псевдослучайные числа генерируются довольно простым образом: берётся некое стартовое базовое число, называемое сидом, то есть зерном. С этим числом производится ряд математических операций и на выходе получается другое число. Генератор перезапускается на новый круг с учетом предыдущих вычислений и выдаёт новое число, и так далее. То есть сид по сути задаёт огромную последовательность чисел, и каждому сиду будет соответствовать своя уникальная последовательность. Если в качестве ключа шифрования мы возьмём сид, а он может быть 32 битным, то получим весьма неплохой набор вариантов. Мы можем записывать наш текст в пиксели, номера которых будут получены из генератора псевдослучайных чисел. Зная этот сид, можно будет прочитать нужные пиксели в нужном порядке и восстановить исходный текст. Если генератор вдруг подкинет номер пикселя, который мы уже записали, нужно будет пропустить этот шаг и получить новое число, для чего будем запоминать номера уже занятых пикселей.
Чтобы при расшифровке знать, что текст закончился, в конце текста я зашиваю в пиксель ноль, то есть вот так. Как только при расшифровке программа натыкается на такой ноль, текст считается расшифрованным. Вот такая маленькая хитрость.
Я добавил в программу окошко для ввода ключа шифрования, сам ключ может состоять из любых букв цифр и символов и иметь любую длину. В исходнике который я оставлю, сид получается простым перемножением кодов символов, что не очень надёжно. Предлагайте в комментариях более надёжные и криптографически стойкие способы генерации пароля, будет интересно почитать. Можно например дополнительно умножать каждый символ на его разность с предыдущим, или что то в этом роде. При плотном расположении пикселей, то есть когда текст занимает почти всю картинку, процесс расшифровки может занимать больше секунды. И взломать такую картинку подбором получится ой как небыстро.
Что я получил в итоге: текст зашивается в изображение, зашивается в псевдослучайный набор пикселей и минимально меняет само изображение, вот даже муха не заметит как говорится. Если закрасить зашифрованные пиксели чёрным, то можно увидеть где именно хранятся буквы. Довольно таки равномерно получается. Чтобы расшифровать такое изображение нужен текстовый ключ шифрования. Теперь к вопросу о размере текста. Фактически один пиксель хранит одну букву, поэтому в картинку с размером 150 на 150 пикселей можно зашакалить аж 22,5 тысячи символов, а это кстати размер сценария к этому видео, 3 листа А4. Не знаю, пригодятся ли кому данные наработки, но как минимум было чертовски интересно во всём этом разобраться. Скачать исходники и готовую скомпилированную программу можно по ссылке в описании, забирайте изучайте. На этом у меня сегодня всё, если у вас есть идеи по поводу того, что ещё и куда можно зашифровать, пишите в коментах, я попробую реализовать ещё что нибудь и сделаю видос. С вами был алекс гайвер, надеюсь, до скорой встречи.
А ЕЩЁ Я ОСТАВИЛ НЕСКОЛЬКО ЗАШИФРОВАННЫХ КАРТИНОК В ПАПКЕ С ПРОГРАММОЙ =) ПАРОЛЬ ALEX_GYVER